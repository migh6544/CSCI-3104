# CSCI-3104
Algorithms

CSCI 3104 is a 4-credit course. During the Fall or Spring semesters, well-prepared students should expect to spend on average 9-12 hours/week outside of class. Students who have significant gaps in their backgrounds may find that they need to carve out additional time to review the prerequisite material.
Algorithms (and Theory/Math courses in general) require more time to gain traction than applied/coding- based courses. Poor early performance is not indicative of one’s ability to succeed (or even earn an A) in this course. Furthermore, student growth (both on an individual level and in the aggregate) in Standards-Based Grading tends to be concave-up. That is, students tend to learn the material and earn credit for standards at a faster rate as the semester progresses. As a rough gauge, students who have, after the first midterm, earned credit for at least 3 standards twice and demonstrated proficiency for another 3-4 standards at least once are likely to be on track to pass the course.

CSCI 3104 Algorithms is an undergraduate course in theoretical computer science. The primary goals include surveying fundamental algorithm design techniques, analyzing algortihm runtime complexities, and identifying computational problems that are unlikely to have efficient algorithmic solutions. We will begin the semester with a survey of including greedy algorithms, including shortest path problems, computing minimum-weight spanning trees, and network flows. Afterwards, we will discuss the technicalities of analyzing an algorithm’s efficiency, including asymptotic notation (e.g., Big-O), and techniques to ascertain and compare the asymptotic runtimes (e.g., Calculus techniques, Recurrences). Once we have a sense of how to analyze algorithms, we will proceed to discuss both the divide & conquer and dynamic programming paradigms. We will also examine our algorithm design techniques closely, discussing both instances where they apply and where they fail to yield the desired results.
At the end of the semester, we will discuss Computational Complexity, which seeks to classify problems into complexity classes based on how efficiently they can be solved. The goal then is to compare these complexity classes, as opposed to individual problems. We will restrict attention to the complexity classes P (the set of decision problems that have efficient solutions) and NP (the set of decision problems where correct solutions can be verified efficiently). While it is known that P ⊆ NP, determining whether P = NP remains the central open problem in Computer Science and one of the six biggest open problems in Math. Resolving the P vs. NP problem will have far-reaching, real-world implications, including on the security of online transactions (cryp- tography), curing cancer (protein folding), scheduling, routing, and a host of other combinatorial optimization problems of practical interest. Our goal will be to understand the statement of the P vs. NP problem, including contextualizing the role that our algorithmic techniques play. Our discussions on the structure of these com- plexity classes will be quite shallow.

We will briefly discuss Hash Tables at the end of the course.
Ultimately, this course is mathematical in nature. The obvious connections are with Discrete Math (Math 3110, Math 3170, Math 4440) and Theoretical Computer Science (CSCI 3434, CSCI 3090, CSCI 4114). However, our algorithmic techniques also serve as key tools in application areas, including Artificial Intelligence (CSCI 3202), Machine Learning (CSCI 3832, CSCI 4622), Bioinformatics (CSCI 4314), Network Science (CSCI 3352), Economics (CSCI 7000 Algorithmic Game Theory, Econ 4050), Operations Research (CSCI 5654), and Circuit Design (ECEN 2350). In order to understand how to adapt and apply our techniques (in this course, subsequent courses, job interviews, or your careers), it is necessary to understand how and why these techniques work. For this reason, formal proofs and the underlying ideas will be examined in great detail. Therefore, a key objective in this course is to develop your mathematical maturity; that is, your ability to understand mathematical statements and formulate rigorous mathematical proofs. This will ultimately be the best indicator for success (outside of hard work). We will rigorously prove mathematical statements in class and discuss proof strategy throughout this course. Every student will be expected to formulate proofs on homework and assessments.
Remark. CSCI 3104 is effectively an abstract math course. This is not a software engineering/coding course. We also stress that while the material we cover has a myriad of applications, the focus will be on developing and understanding the techniques rather than on the applications themselves. Our goal will be to prepare students to apply the techniques we develop beyond this course.

Algorithms is one of the key maturity courses for undergraduates in Computer Science programs (the others being Systems and Principles of Programming Languages). The obvious course objective is gaining proficiency with the material outlined above. Beyond that, the development of rigorous mathematical thought, mathemat- ical maturity, and sharpness of proof writing will be emphasized. The underlying goal is for you to improve your ability to read and write mathematics, as well as appreciate the design and usage of axioms in a theoretical discipline. A third goal is to provide a solid preparation for subsequent courses that utilize rigorous algorithmic techniques. To this end, we have the following learning objectives.
